{"version":3,"file":"linear-progress.js","sourceRoot":"","sources":["linear-progress.ts"],"names":[],"mappings":"AAAA;;;;GAIG;;AAEH,OAAO,EAAC,IAAI,EAAC,MAAM,KAAK,CAAC;AACzB,OAAO,EAAC,QAAQ,EAAC,MAAM,mBAAmB,CAAC;AAC3C,OAAO,EAAC,QAAQ,EAAC,MAAM,6BAA6B,CAAC;AAErD,OAAO,EAAC,QAAQ,EAAC,MAAM,eAAe,CAAC;AAEvC;;GAEG;AACH,MAAM,OAAO,cAAe,SAAQ,QAAQ;IAA5C;;QACE;;;WAGG;QACuB,WAAM,GAAG,CAAC,CAAC;IAoCvC,CAAC;IAlCC,mEAAmE;IACnE,8EAA8E;IAC9E,mDAAmD;IAChC,eAAe;QAChC,MAAM,cAAc,GAAG;YACrB,SAAS,EAAE,UACT,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,GACrD,IAAI;SACL,CAAC;QAEF,MAAM,WAAW,GAAG,IAAI,CAAC,MAAM,IAAI,CAAC,CAAC;QACrC,MAAM,SAAS,GAAG,WAAW,GAAG,CAAC,CAAC;QAElC,MAAM,OAAO,GAAG,IAAI,CAAC,aAAa,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC;QAE9E,MAAM,SAAS,GAAG;YAChB,SAAS,EAAE,UAAU,OAAO,GAAG,GAAG,IAAI;SACvC,CAAC;QAEF,oEAAoE;QACpE,aAAa;QACb,MAAM,QAAQ,GACZ,IAAI,CAAC,aAAa,IAAI,CAAC,SAAS,IAAI,WAAW,IAAI,IAAI,CAAC,GAAG,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,GAAG,CAAC;QACxF,OAAO,IAAI,CAAA;kCACmB,QAAQ;0CACA,QAAQ,CAAC,SAAS,CAAC;2CAClB,QAAQ,CAAC,cAAc,CAAC;;;;;;KAM9D,CAAC;IACJ,CAAC;CACF;AApC2B;IAAzB,QAAQ,CAAC,EAAC,IAAI,EAAE,MAAM,EAAC,CAAC;8CAAY","sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {html} from 'lit';\nimport {property} from 'lit/decorators.js';\nimport {styleMap} from 'lit/directives/style-map.js';\n\nimport {Progress} from './progress.js';\n\n/**\n * A linear progress component.\n */\nexport class LinearProgress extends Progress {\n  /**\n   * Buffer amount to display, a fraction between 0 and `max`.\n   * If the value is 0 or negative, the buffer is not displayed.\n   */\n  @property({type: Number}) buffer = 0;\n\n  // Note, the indeterminate animation is rendered with transform %'s\n  // Previously, this was optimized to use px calculated with the resizeObserver\n  // due to a now fixed Chrome bug: crbug.com/389359.\n  protected override renderIndicator() {\n    const progressStyles = {\n      transform: `scaleX(${\n        (this.indeterminate ? 1 : this.value / this.max) * 100\n      }%)`,\n    };\n\n    const bufferValue = this.buffer ?? 0;\n    const hasBuffer = bufferValue > 0;\n\n    const dotSize = this.indeterminate || !hasBuffer ? 1 : bufferValue / this.max;\n\n    const dotStyles = {\n      transform: `scaleX(${dotSize * 100}%)`,\n    };\n\n    // Only display dots when visible - this prevents invisible infinite\n    // animation.\n    const hideDots =\n      this.indeterminate || !hasBuffer || bufferValue >= this.max || this.value >= this.max;\n    return html`\n      <div class=\"dots\" ?hidden=${hideDots}></div>\n      <div class=\"inactive-track\" style=${styleMap(dotStyles)}></div>\n      <div class=\"bar primary-bar\" style=${styleMap(progressStyles)}>\n        <div class=\"bar-inner\"></div>\n      </div>\n      <div class=\"bar secondary-bar\">\n        <div class=\"bar-inner\"></div>\n      </div>\n    `;\n  }\n}\n"]}